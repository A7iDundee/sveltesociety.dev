{
  "data": {
    "title": "Data Fetching",
    "contents": "<h2 id=\"using-fetch-to-consume-apis-with-svelte\">Using Fetch to Consume APIs with Svelte</h2>\n<p>Working with external data in Svelte is important. Here&#39;s a guide.</p>\n<p><em>Maintainers of this Recipe: <a href=\"https://twitter.com/swyx\">swyx</a></em></p>\n<h3 id=\"fetching-on-component-mount-in-svelte\">Fetching on Component Mount in Svelte</h3>\n<p><strong>Method 1: Using Lifecycles</strong></p>\n<p>We can declare a <code>data</code> variable and use the <code>onMount</code> lifecycle to fetch on mount and display data in our component:</p>\n<pre><code class=\"language-html\">&lt;!-- https://svelte.dev/repl/99c18a89f05d4682baa83cb673135f05?version=3.20.1 --&gt;\n&lt;script&gt;\n  import { onMount } from &quot;svelte&quot;;\n  let data;\n  onMount(async () =&gt; {\n    data = await fetch(\n      &quot;https://api.coindesk.com/v1/bpi/currentprice.json&quot;\n    ).then((x) =&gt; x.json());\n  });\n&lt;/script&gt;\n\n&lt;pre&gt;\n  {JSON.stringify(data, null, 2)}\n&lt;/pre&gt;</code></pre>\n<p>You can further improve this implementation by showing a placeholder while <code>data</code> is undefined and also showing an error notification if an error occurs.</p>\n<p><strong>Method 2: Using Await Blocks</strong></p>\n<p>Since it is very common to update your app based on the status of your data fetching, Svelte offers convenient <a href=\"https://svelte.dev/docs#await\">await blocks</a> to help.</p>\n<p>This example is exactly equal to Method 1 above:</p>\n<pre><code class=\"language-html\">&lt;!-- https://svelte.dev/repl/977486a651a34eb5bd9167f989ae3e71?version=3.20.1 --&gt;\n&lt;script&gt;\n  let promise = fetch(\n    &quot;https://api.coindesk.com/v1/bpi/currentprice.json&quot;\n  ).then((x) =&gt; x.json());\n&lt;/script&gt;\n\n{#await promise}\n&lt;!-- optionally show something while promise is pending --&gt;\n{:then data}\n&lt;!-- promise was fulfilled --&gt;\n&lt;pre&gt;\n        {JSON.stringify(data, null, 2)}\n    &lt;/pre\n&gt;\n{:catch error}\n&lt;!-- optionally show something while promise was rejected --&gt;\n{/await}</code></pre>\n<p>Here you can see that it is very intuitive where to place your loading placeholder and error display.</p>\n<p>Related Reading:</p>\n<ul>\n<li><a href=\"https://svelte.dev/docs#2_Assignments_are_reactive\">https://svelte.dev/docs#2_Assignments_are_reactive</a></li>\n<li><a href=\"https://svelte.dev/docs#onMount\">https://svelte.dev/docs#onMount</a></li>\n<li><a href=\"https://svelte.dev/docs#Attributes_and_props\">https://svelte.dev/docs#Attributes_and_props</a></li>\n<li><a href=\"https://svelte.dev/docs#await\">https://svelte.dev/docs#await</a></li>\n</ul>\n<h3 id=\"fetching-on-button-click-in-svelte\">Fetching on Button Click in Svelte</h3>\n<p>One flaw with the above approach is that it does not offer a way for the user to refetch data, and additionally we may not want to render on mount (for data saving or UX reasons).</p>\n<p><strong>Method 1: Simple Click Handler</strong></p>\n<p>If we don&#39;t want to immediately load data on component mount, we can wait for user interaction instead:</p>\n<pre><code class=\"language-html\">&lt;!-- https://svelte.dev/repl/2a8db7627c4744008203ecf12806eb1f?version=3.20.1 --&gt;\n&lt;script&gt;\n  let data;\n  const handleClick = async () =&gt; {\n    data = await fetch(\n      &quot;https://api.coindesk.com/v1/bpi/currentprice.json&quot;\n    ).then((x) =&gt; x.json());\n  };\n&lt;/script&gt;\n\n&lt;button on:click=&quot;{handleClick}&quot;&gt;\n  Click to Load Data\n&lt;/button&gt;\n&lt;pre&gt;\n  {JSON.stringify(data, null, 2)}\n&lt;/pre&gt;</code></pre>\n<p>The user now has an intuitive way to refresh their data.</p>\n<p>However, there are some problems with this approach. You may still need to declare an extra variable to display error state. More subtly, when the user clicks for a refresh, the stale data still displays on screen, if you are not careful.</p>\n<p><strong>Method 2: Await Blocks</strong></p>\n<p>It would be better to make all these commonplace UI idioms declarative. Await blocks to the rescue again:</p>\n<pre><code class=\"language-html\">&lt;!-- https://svelte.dev/repl/98ec1a9a45af4d75ac5bbcb1b5bcb160?version=3.20.1 --&gt;\n&lt;script&gt;\n  let promise;\n  const handleClick = () =&gt; {\n    promise = fetch(\n      &quot;https://api.coindesk.com/v1/bpi/currentprice.json&quot;\n    ).then((x) =&gt; x.json());\n  };\n&lt;/script&gt;\n\n&lt;button on:click=&quot;{handleClick}&quot;&gt;\n  Click to Load Data\n&lt;/button&gt;\n\n{#await promise}\n&lt;!-- optionally show something while promise is pending --&gt;\n{:then data}\n&lt;!-- promise was fulfilled --&gt;\n&lt;pre&gt;\n    {JSON.stringify(data, null, 2)}\n  &lt;/pre\n&gt;\n{:catch error}\n&lt;!-- optionally show something while promise was rejected --&gt;\n{/await}</code></pre>\n<p>The trick here is we can simply reassign the <code>promise</code> to trigger a refetch, which then also clears the UI of stale data while fetching.</p>\n<p><strong>Method 3: Promise Swapping</strong></p>\n<p>Of course, it is up to you what UX you want - you may wish to keep displaying stale data and merely display a loading indicator instead while fetching the new data. Here&#39;s a possible solution using a second promise to execute the data fetching while the main promise stays onscreen:</p>\n<pre><code class=\"language-html\">&lt;!-- https://svelte.dev/repl/21e932515ab24a6fb7ab6d411cce2799?version=3.20.1 --&gt;\n&lt;script&gt;\n  let promise1, promise2;\n  const handleClick = () =&gt; {\n    promise2 = new Promise((res) =&gt;\n      setTimeout(() =&gt; res(Math.random()), 1000)\n    ).then((x) =&gt; {\n      promise1 = promise2;\n      return x;\n    });\n  };\n&lt;/script&gt;\n\n&lt;button on:click=&quot;{handleClick}&quot;&gt;\n  Click to Load Data {#await promise2}ðŸŒ€{/await}\n&lt;/button&gt;\n\n{#await promise1}\n&lt;!-- optionally show something while promise is pending --&gt;\n{:then value}\n&lt;!-- promise was fulfilled --&gt;\n&lt;pre&gt;\n    {value}\n  &lt;/pre\n&gt;\n{:catch error}\n&lt;!-- optionally show something while promise was rejected --&gt;\n{/await}</code></pre>\n<h3 id=\"dealing-with-cors-errors-in-svelte\">Dealing with CORS Errors in Svelte</h3>\n<p>Svelte is purely a frontend framework, so it will be subject to the same CORS restrictions that any frontend framework faces. You will run into CORS issues in two ways:</p>\n<ol>\n<li>In local development (making requests from <code>http://localhost</code> to <code>https://myapi.com</code>)</li>\n<li>In production (making requests from <code>https://mydomain.com</code> to <code>https://theirapi.com</code>)</li>\n</ol>\n<p>You can solve both with a range of solutions from having a local API dev server or proxying requests through a serverless function or API gateway. None are responsibilities of Svelte but here are some helpful resources that may help:</p>\n<ul>\n<li><a href=\"https://alligator.io/nodejs/solve-cors-once-and-for-all-netlify-dev/\">https://alligator.io/nodejs/solve-cors-once-and-for-all-netlify-dev/</a></li>\n<li><a href=\"https://zeit.co/docs/v2/serverless-functions/introduction\">https://zeit.co/docs/v2/serverless-functions/introduction</a></li>\n<li><a href=\"https://docs.begin.com/en/http-functions/api-reference\">https://docs.begin.com/en/http-functions/api-reference</a></li>\n<li><a href=\"https://aws.amazon.com/blogs/mobile/amplify-framework-local-mocking/\">https://aws.amazon.com/blogs/mobile/amplify-framework-local-mocking/</a></li>\n</ul>\n<p>If you happen to be running <a href=\"https://sapper.svelte.dev/\">a Sapper app</a>, then you may take advantage of preloading data server-side in Sapper: <a href=\"https://sapper.svelte.dev/docs#Preloading\">https://sapper.svelte.dev/docs#Preloading</a>.</p>\n<p>You now have all you need to work with Data APIs in Svelte.</p>\n<h3 id=\"further-links\">Further Links</h3>\n<ul>\n<li>Svelte Suspense discussion: <a href=\"https://github.com/sveltejs/svelte/issues/1736\">https://github.com/sveltejs/svelte/issues/1736</a></li>\n<li>Your link here?</li>\n</ul>\n"
  },
  "preprocessors": {
    "title": "Build Setup Recipes",
    "contents": "<h1 id=\"build-setup-recipes\">Build Setup Recipes</h1>\n<h2 id=\"using-svelte-preprocessors-for-scss-typescript-and-babel-\">Using Svelte Preprocessors (for SCSS, TypeScript, and Babel)</h2>\n<p><em>to be written</em></p>\n<p>related issues: <a href=\"https://github.com/svelte-society/recipes-mvp/issues/8\">https://github.com/svelte-society/recipes-mvp/issues/8</a></p>\n<h2 id=\"preprocessors\">Preprocessors</h2>\n<blockquote>\n<p>This article references <code>svelte.preprocess</code> throughout but you may be more familiar with the <code>preprocess</code> option of <code>svelte-loader</code> or <code>rollup-plugin-svelte</code>. This <code>preprocess</code> option calls <code>svelte.preprocess</code> internally. The bundler plugin gives you easy access to it, so you don&#39;t need to transform your components before compilation manually.</p>\n</blockquote>\n<p>The Svelte compiler expects all components it receives to be valid Svelte syntax. To use compile-to-js or compile-to-css languages, you need to make sure that any non-standard syntax is transformed before Svelte tries to parse it. To enable this Svelte provides a <code>preprocess</code> method allowing you to transform different parts of the component before it reaches the compiler.</p>\n<p>With <code>svelte.preprocess</code> you have a great deal of flexibility in how you write your components while ensuring that the Svelte compiler receives a plain component.</p>\n<h3 id=\"svelte-preprocess\">svelte.preprocess</h3>\n<p>Svelte&#39;s <code>preprocess</code> method expects an object or an array of objects with one or more of <code>markup</code>, <code>script</code>, and <code>style</code> properties, each being a function receiving the source code as an argument. The preprocessors run in this order.</p>\n<pre><code class=\"language-js\">const preprocess = {\n  markup,\n  script,\n  style,\n};</code></pre>\n<p>In general, preprocessors receive the component source code and must return the transformed source code, either as a string or as an object containing a <code>code</code> and <code>map</code> property. The <code>code</code> property must contain the transformed source code, while the <code>map</code> property can optionally contain a sourcemap. The sourcemap is currently unused by Svelte.</p>\n<h3 id=\"markup-preprocessors\">Markup preprocessors</h3>\n<p><em>to be written</em></p>\n<h3 id=\"script-preprocessors\">Script preprocessors</h3>\n<p><em>to be written</em></p>\n<h3 id=\"style-preprocessors\">Style preprocessors</h3>\n<p><em>to be written</em></p>\n<h2 id=\"how-to-make-a-pre-processor-that-makes-it-possible-to-use-pug-jade\">How to make a pre-processor that makes it possible to use PUG/Jade</h2>\n<p><em>to be written</em></p>\n"
  }
}
